<head><meta charset="UTF-8"></head><h1 class="heading">redo日志（上）</h1>
<p>标签： MySQL是怎样运行的</p>
<hr>
<h2 class="heading">事先说明</h2>
<p>本文以及接下来的几篇文章将会频繁的使用到我们前边唠叨的<code>InnoDB</code>记录行格式、页面格式、索引原理、表空间的组成等各种基础知识，如果大家对这些东西理解的不透彻，那么阅读下边的文字可能会有些吃力，为保证您的阅读体验，请确保自己已经掌握了我前边唠叨的这些知识。</p>
<h2 class="heading">redo日志是个啥</h2>
<p>我们知道<code>InnoDB</code>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。我们前边唠叨<code>Buffer Pool</code>的时候说过，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<code>Buffer Pool</code>之后才可以访问。但是在唠叨事务的时候又强调过一个称之为<code>持久性</code>的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失。但是如果我们只在内存的<code>Buffer Pool</code>中修改了页面，假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交了的事务对数据库中所做的更改也就跟着丢失了，这是我们所不能忍受的（想想ATM机已经提示狗哥转账成功，但之后由于服务器出现故障，重启之后猫爷发现自己没收到钱，猫爷就被砍死了）。那么如何保证这个<code>持久性</code>呢？一个很简单的做法就是<span style="color:red">在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘</span>，但是这个简单粗暴的做法有些问题：</p>
<ul>
<li>
<p>刷新一个完整的数据页太浪费了</p>
<p>有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在<code>InnoDB</code>中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。</p>
</li>
<li>
<p>随机IO刷起来比较慢</p>
<p>一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的<code>Buffer Pool</code>中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。</p>
</li>
</ul>
<p>咋办呢？再次回到我们的初心：<span style="color:red">我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来</span>。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要<span style="color:red">把修改了哪些东西记录一下就好</span>，比方说某个事务将系统表空间中的第100号页面中偏移量为1000处的那个字节的值<code>1</code>改成<code>2</code>我们只需要记录一下：</p>
<blockquote>
<p>将第0号表空间的100号页面的偏移量为1000处的值更新为<code>2</code>。</p>
</blockquote>
<p>这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来，也就意味着满足<code>持久性</code>的要求。因为在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为<code>重做日志</code>，英文名为<code>redo log</code>，我们也可以土洋结合，称之为<code>redo日志</code>。与在事务提交时将所有修改过的内存中的页面刷新到磁盘中相比，只将该事务执行过程中产生的<code>redo</code>日志刷新到磁盘的好处如下：</p>
<ul>
<li>
<p><code>redo</code>日志占用的空间非常小</p>
<p>存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于<code>redo</code>日志的格式我们稍后会详细唠叨，现在只要知道一条<code>redo</code>日志占用的空间不是很大就好了。</p>
</li>
<li>
<p><code>redo</code>日志是顺序写入磁盘的</p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条<code>redo</code>日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。</p>
</li>
</ul>
<h2 class="heading">redo日志格式</h2>
<p>通过上边的内容我们知道，<code>redo</code>日志本质上只是<span style="color:red">记录了一下事务对数据库做了哪些修改</span>。 设计<code>InnoDB</code>的大叔们针对事务对数据库的不同修改场景定义了多种类型的<code>redo</code>日志，但是绝大部分类型的<code>redo</code>日志都有下边这种通用的结构：</p>
<p></p><figure><img alt="image_1d36k7d3412oo1c0qcuuben12l79.png-31.3kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fdec61898?w=982&amp;h=253&amp;f=png&amp;s=32063"><figcaption></figcaption></figure><p></p>
<p>各个部分的详细释义如下：</p>
<ul>
<li>
<p><code>type</code>：该条<code>redo</code>日志的类型。</p>
<p>在<code>MySQL 5.7.21</code>这个版本中，设计<code>InnoDB</code>的大叔一共为<code>redo</code>日志设计了53种不同的类型，稍后会详细介绍不同类型的<code>redo</code>日志。</p>
</li>
<li>
<p><code>space ID</code>：表空间ID。</p>
</li>
<li>
<p><code>page number</code>：页号。</p>
</li>
<li>
<p><code>data</code>：该条<code>redo</code>日志的具体内容。</p>
</li>
</ul>
<h3 class="heading">简单的redo日志类型</h3>
<p>我们前边介绍<code>InnoDB</code>的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义<code>Unique</code>键，那么<code>InnoDB</code>会自动的为表添加一个称之为<code>row_id</code>的隐藏列作为主键。为这个<code>row_id</code>隐藏列赋值的方式如下：</p>
<ul>
<li>
<p>服务器会在内存中维护一个全局变量，每当向某个包含隐藏的<code>row_id</code>列的表中插入一条记录时，就会把该变量的值当作新记录的<code>row_id</code>列的值，并且把该变量自增1。</p>
</li>
<li>
<p>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为<code>7</code>的页面中一个称之为<code>Max Row ID</code>的属性处（我们前边介绍表空间结构时详细说过）。</p>
</li>
<li>
<p>当系统启动时，会将上边提到的<code>Max Row ID</code>属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于<code>Max Row ID</code>属性值）。</p>
</li>
</ul>
<p>这个<code>Max Row ID</code>属性占用的存储空间是8个字节，当某个事务向某个包含<code>row_id</code>隐藏列的表插入一条记录，并且为该记录分配的<code>row_id</code>值为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。但是我们要知道，这个写入实际上是在<code>Buffer Pool</code>中完成的，我们需要为这个页面的修改记录一条<code>redo</code>日志，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页面的修改是极其简单的，<code>redo</code>日志中只需要<span style="color:red">记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了</span>，设计<code>InnoDB</code>的大叔把这种极其简单的<code>redo</code>日志称之为<code>物理日志</code>，并且根据在页面中写入数据的多少划分了几种不同的<code>redo</code>日志类型：</p>
<ul>
<li>
<p><code>MLOG_1BYTE</code>（<code>type</code>字段对应的十进制数字为<code>1</code>）：表示在页面的某个偏移量处写入1个字节的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_2BYTE</code>（<code>type</code>字段对应的十进制数字为<code>2</code>）：表示在页面的某个偏移量处写入2个字节的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_4BYTE</code>（<code>type</code>字段对应的十进制数字为<code>4</code>）：表示在页面的某个偏移量处写入4个字节的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_8BYTE</code>（<code>type</code>字段对应的十进制数字为<code>8</code>）：表示在页面的某个偏移量处写入8个字节的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_WRITE_STRING</code>（<code>type</code>字段对应的十进制数字为<code>30</code>）：表示在页面的某个偏移量处写入一串数据。</p>
</li>
</ul>
<p>我们上边提到的<code>Max Row ID</code>属性实际占用8个字节的存储空间，所以在修改页面中的该属性时，会记录一条类型为<code>MLOG_8BYTE</code>的<code>redo</code>日志，<code>MLOG_8BYTE</code>的<code>redo</code>日志结构如下所示：</p>
<p></p><figure><img alt="image_1d3fv01mv3jd7m719rpmn2jcsp.png-42.6kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fdf053082?w=839&amp;h=291&amp;f=png&amp;s=43606"><figcaption></figcaption></figure><p></p>
<p>其余<code>MLOG_1BYTE</code>、<code>MLOG_2BYTE</code>、<code>MLOG_4BYTE</code>类型的<code>redo</code>日志结构和<code>MLOG_8BYTE</code>的类似，只不过具体数据中包含对应个字节的数据罢了。<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个<code>len</code>字段：</p>
<p></p><figure><img alt="image_1d3fv8at819jh1m7m1sfb1donvmu16.png-47.2kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fdf3da823?w=878&amp;h=299&amp;f=png&amp;s=48358"><figcaption></figcaption></figure><p></p>
<blockquote class="warning"><p>小贴士：

只要将MLOG_WRITE_STRING类型的redo日志的len字段填充上1、2、4、8这些数字，就可以分别替代MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE、MLOG_8BYTE这些类型的redo日志，为啥还要多此一举设计这么多类型呢？还不是因为省空间啊，能不写len字段就不写len字段，省一个字节算一个字节。
</p></blockquote><h3 class="heading">复杂一些的redo日志类型</h3>
<p>有时候执行一条语句会修改非常多的页面，包括系统数据页面和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的<code>B+</code>树）。以一条<code>INSERT</code>语句为例，它除了要向<code>B+</code>树的页面中插入数据，也可能更新系统数据<code>Max Row ID</code>的值，不过对于我们用户来说，平时更关心的是语句对<code>B+</code>树所做更新：</p>
<ul>
<li>
<p>表中包含多少个索引，一条<code>INSERT</code>语句就可能更新多少棵<code>B+</code>树。</p>
</li>
<li>
<p>针对某一棵<code>B+</code>树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂，在内节点页面中添加<code>目录项记录</code>）。</p>
</li>
</ul>
<p>在语句执行过程中，<code>INSERT</code>语句对所有页面的修改都得保存到<code>redo</code>日志中去。这句话说的比较轻巧，做起来可就比较麻烦了，比方说将记录插入到聚簇索引中时，如果定位到的叶子节点的剩余空间足够存储该记录时，那么只更新该叶子节点页面就好，那么只记录一条<code>MLOG_WRITE_STRING</code>类型的<code>redo</code>日志，表明在页面的某个偏移量处增加了哪些数据就好了么？那就too young too naive了～ 别忘了一个数据页中除了存储实际的记录之后，还有什么<code>File Header</code>、<code>Page Header</code>、<code>Page Directory</code>等等部分（在唠叨数据页的章节有详细讲解），所以每往叶子节点代表的数据页里插入一条记录时，还有其他很多地方会跟着更新，比如说：</p>
<ul>
<li>
<p>可能更新<code>Page Directory</code>中的槽信息。</p>
</li>
<li>
<p><code>Page Header</code>中的各种页面统计信息，比如<code>PAGE_N_DIR_SLOTS</code>表示的槽数量可能会更改，<code>PAGE_HEAP_TOP</code>代表的还未使用的空间最小地址可能会更改，<code>PAGE_N_HEAP</code>代表的本页面中的记录数量可能会更改，吧啦吧啦，各种信息都可能会被修改。</p>
</li>
<li>
<p>我们知道在数据页里的记录是按照索引列从小到大的顺序组成一个单向链表的，每插入一条记录，还需要更新上一条记录的记录头信息中的<code>next_record</code>属性来维护这个单向链表。</p>
</li>
<li>
<p>还有别的吧啦吧啦的更新的地方，就不一一唠叨了...</p>
</li>
</ul>
<p>画一个简易的示意图就像是这样：</p>
<p></p><figure><img alt="image_1d3gv4i7vtsirf81ikl1q2140n2g.png-67.2kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fdfa7d8ce?w=1127&amp;h=524&amp;f=png&amp;s=68863"><figcaption></figcaption></figure><p></p>
<p>说了这么多，就是想表达：<span style="color:red">把一条记录插入到一个页面时需要更改的地方非常多</span>。这时我们如果使用上边介绍的简单的物理<code>redo</code>日志来记录这些修改时，可以有两种解决方案：</p>
<ul>
<li>
<p>方案一：在每个修改的地方都记录一条<code>redo</code>日志。</p>
<p>也就是如上图所示，有多少个加粗的块，就写多少条物理<code>redo</code>日志。这样子记录<code>redo</code>日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的<code>redo</code>日志占用的空间都比整个页面占用的空间都多了～</p>
</li>
<li>
<p>方案二：将整个页面的<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间所有的数据当成是一条物理<code>redo</code>日志中的具体数据。</p>
<p>从图中也可以看出来，<code>第一个被修改的字节</code>到<code>最后一个修改的字节</code>之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到<code>redo</code>日志中去岂不是太浪费了～</p>
</li>
</ul>
<p>正因为上述两种使用物理<code>redo</code>日志的方式来记录某个页面中做了哪些修改比较浪费，设计<code>InnoDB</code>的大叔本着勤俭节约的初心，提出了一些新的<code>redo</code>日志类型，比如：</p>
<ul>
<li>
<p><code>MLOG_REC_INSERT</code>（对应的十进制数字为<code>9</code>）：表示插入一条使用非紧凑行格式的记录时的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_COMP_REC_INSERT</code>（对应的十进制数字为<code>38</code>）：表示插入一条使用紧凑行格式的记录时的<code>redo</code>日志类型。</p>
</li>
</ul>
<blockquote class="warning"><p>小贴士：

Redundant是一种比较原始的行格式，它就是非紧凑的。而Compact、Dynamic以及Compressed行格式是较新的行格式，它们是紧凑的（占用更小的存储空间）。
</p></blockquote><ul>
<li>
<p><code>MLOG_COMP_PAGE_CREATE</code>（<code>type</code>字段对应的十进制数字为<code>58</code>）：表示创建一个存储紧凑行格式记录的页面的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_COMP_REC_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>42</code>）：表示删除一条使用紧凑行格式记录的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_COMP_LIST_START_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>44</code>）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的<code>redo</code>日志类型。</p>
</li>
<li>
<p><code>MLOG_COMP_LIST_END_DELETE</code>（<code>type</code>字段对应的十进制数字为<code>43</code>）：与<code>MLOG_COMP_LIST_START_DELETE</code>类型的<code>redo</code>日志呼应，表示删除一系列记录直到<code>MLOG_COMP_LIST_END_DELETE</code>类型的<code>redo</code>日志对应的记录为止。</p>
</li>
</ul>
<blockquote class="warning"><p>小贴士：

我们前边唠叨InnoDB数据页格式的时候重点强调过，数据页中的记录是按照索引列大小的顺序组成单向链表的。有时候我们会有删除索引列的值在某个区间范围内的所有记录的需求，这时候如果我们每删除一条记录就写一条redo日志的话，效率可能有点低，所以提出MLOG_COMP_LIST_START_DELETE和MLOG_COMP_LIST_END_DELETE类型的redo日志，可以很大程度上减少redo日志的条数。
</p></blockquote><ul>
<li>
<p><code>MLOG_ZIP_PAGE_COMPRESS</code>（<code>type</code>字段对应的十进制数字为<code>51</code>）：表示压缩一个数据页的<code>redo</code>日志类型。</p>
</li>
<li>
<p>······还有很多很多种类型，这就不列举了，等用到再说哈～</p>
</li>
</ul>
<p>这些类型的<code>redo</code>日志既包含<code>物理</code>层面的意思，也包含<code>逻辑</code>层面的意思，具体指：</p>
<ul>
<li>
<p>物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。</p>
</li>
<li>
<p>逻辑层面看，在系统奔溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统奔溃前的样子。</p>
</li>
</ul>
<p>大家看到这可能有些懵逼，我们还是以类型为<code>MLOG_COMP_REC_INSERT</code>这个代表插入一条使用紧凑行格式的记录时的<code>redo</code>日志为例来理解一下我们上边所说的<code>物理</code>层面和<code>逻辑</code>层面到底是个啥意思。废话少说，直接看一下这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志的结构（由于字段太多了，我们把它们竖着看效果好些）：</p>
<p></p><figure><img alt="image_1d3bn8tsq1ssp1nmdks8kdr17e31t.png-85.7kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fe02553d0?w=565&amp;h=625&amp;f=png&amp;s=87737"><figcaption></figcaption></figure><p></p>
<p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志结构有几个地方需要大家注意：</p>
<ul>
<li>
<p>我们前边在唠叨索引的时候说过，在一个数据页里，不论是叶子节点还是非叶子节点，记录都是按照索引列从小到大的顺序排序的。对于二级索引来说，当索引列的值相同时，记录还需要按照主键值进行排序。图中<code>n_uniques</code>的值的含义是在一条记录中，需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前<code>n_uniques</code>个字段进行排序。对于聚簇索引来说，<code>n_uniques</code>的值为主键的列数，对于其他二级索引来说，该值为索引列数+主键列数。这里需要注意的是，唯一二级索引的值可能为<code>NULL</code>，所以该值仍然为索引列数+主键列数。</p>
</li>
<li>
<p><code>field1_len ~ fieldn_len</code>代表着该记录若干个字段占用存储空间的大小，需要注意的是，这里不管该字段的类型是固定长度大小的（比如<code>INT</code>），还是可变长度大小（比如<code>VARCHAR(M)</code>）的，该字段占用的大小始终要写入<code>redo</code>日志中。</p>
</li>
<li>
<p><code>offset</code>代表的是该记录的前一条记录在页面中的地址。为啥要记录前一条记录的地址呢？这是因为每向数据页插入一条记录，都需要修改该页面中维护的记录链表，每条记录的<code>记录头信息</code>中都包含一个称为<code>next_record</code>的属性，所以在插入新记录时，需要修改前一条记录的<code>next_record</code>属性。</p>
</li>
<li>
<p>我们知道一条记录其实由<code>额外信息</code>和<code>真实数据</code>这两部分组成，这两个部分的总大小就是一条记录占用存储空间的总大小。通过<code>end_seg_len</code>的值可以间接的计算出一条记录占用存储空间的总大小，为啥不直接存储一条记录占用存储空间的总大小呢？这是因为写<code>redo</code>日志是一个非常频繁的操作，设计<code>InnoDB</code>的大叔想方设法想减小<code>redo</code>日志本身占用的存储空间大小，所以想了一些弯弯绕的算法来实现这个目标，<code>end_seg_len</code>这个字段就是为了节省<code>redo</code>日志存储空间而提出来的。至于具体设计<code>InnoDB</code>的大叔到底是用了什么神奇魔法减小<code>redo</code>日志大小的，我们这就不多唠叨了，因为的确有那么一丢丢小复杂，说清楚还是有一点点麻烦的，而且说明白了也没啥用。</p>
</li>
<li>
<p><code>mismatch_index</code>的值也是为了节省<code>redo</code>日志的大小而设立的，大家可以忽略。</p>
</li>
</ul>
<p>很显然这个类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志并没有记录<code>PAGE_N_DIR_SLOTS</code>的值修改为了啥，<code>PAGE_HEAP_TOP</code>的值修改为了啥，<code>PAGE_N_HEAP</code>的值修改为了啥等等这些信息，而只是把在本页面中插入一条记录所有必备的要素记了下来，之后系统奔溃重启时，服务器会调用相关向某个页面插入一条记录的那个函数，而<code>redo</code>日志中的那些数据就可以被当成是调用这个函数所需的参数，在调用完该函数后，页面中的<code>PAGE_N_DIR_SLOTS</code>、<code>PAGE_HEAP_TOP</code>、<code>PAGE_N_HEAP</code>等等的值也就都被恢复到系统奔溃前的样子了。这就是所谓的<code>逻辑</code>日志的意思。</p>
<h3 class="heading">redo日志格式小结</h3>
<p>虽然上边说了一大堆关于<code>redo</code>日志格式的内容，但是如果你不是为了写一个解析<code>redo</code>日志的工具或者自己开发一套<code>redo</code>日志系统的话，那就没必要把<code>InnoDB</code>中的各种类型的<code>redo</code>日志格式都研究的透透的，没那个必要。上边我只是象征性的介绍了几种类型的<code>redo</code>日志格式，目的还是想让大家明白：<span style="color:red">redo日志会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来</span>。</p>
<blockquote class="warning"><p>小贴士：

为了节省redo日志占用的存储空间大小，设计InnoDB的大叔对redo日志中的某些数据还可能进行压缩处理，比方说spacd ID和page number一般占用4个字节来存储，但是经过压缩后，可能使用更小的空间来存储。具体压缩算法就不唠叨了。
</p></blockquote><h2 class="heading">Mini-Transaction</h2>
<h3 class="heading">以组的形式写入redo日志</h3>
<p>语句在执行过程中可能修改若干个页面。比如我们前边说的一条<code>INSERT</code>语句可能修改系统表空间页号为<code>7</code>的页面的<code>Max Row ID</code>属性（当然也可能更新别的系统页面，只不过我们没有都列举出来而已），还会更新聚簇索引和二级索引对应<code>B+</code>树中的页面。由于对这些页面的更改都发生在<code>Buffer Pool</code>中，所以在修改完页面之后，需要记录一下相应的<code>redo</code>日志。在执行语句的过程中产生的<code>redo</code>日志被设计<code>InnoDB</code>的大叔人为的划分成了若干个不可分割的组，比如：</p>
<ul>
<li>
<p>更新<code>Max Row ID</code>属性时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li>
<p>向聚簇索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li>
<p>向某个二级索引对应<code>B+</code>树的页面中插入一条记录时产生的<code>redo</code>日志是不可分割的。</p>
</li>
<li>
<p>还有其他的一些对页面的访问操作时产生的<code>redo</code>日志是不可分割的。。。</p>
</li>
</ul>
<p>怎么理解这个<code>不可分割</code>的意思呢？我们以向某个索引对应的<code>B+</code>树插入一条记录为例，在向<code>B+</code>树中插入这条记录之前，需要先定位到这条记录应该被插入到哪个叶子节点代表的数据页中，定位到具体的数据页之后，有两种可能的情况：</p>
<ul>
<li>
<p>情况一：该数据页的剩余的空闲空间充足，足够容纳这一条待插入记录，那么事情很简单，直接把记录插入到这个数据页中，记录一条类型为<code>MLOG_COMP_REC_INSERT</code>的<code>redo</code>日志就好了，我们把这种情况称之为<code>乐观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p>
<p></p><figure><img alt="image_1d4fc7b6b1ftt16ji11as4a63h23.png-30.8kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694892fe05a2603?w=722&amp;h=458&amp;f=png&amp;s=31490"><figcaption></figcaption></figure><p></p>
<p>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，由于<code>页b</code>现在有足够的空间容纳一条记录，所以直接将该记录插入到<code>页b</code>中就好了，就像这样：</p>
<p></p><figure><img alt="image_1d4fcbg9e1m1b1qtj1emgphorrl2g.png-43.3kB" src="https://user-gold-cdn.xitu.io/2019/3/4/16948930120794a0?w=711&amp;h=559&amp;f=png&amp;s=44305"><figcaption></figcaption></figure><p></p>
</li>
<li>
<p>情况二：该数据页剩余的空闲空间不足，那么事情就悲剧了，我们前边说过，遇到这种情况要进行所谓的<code>页分裂</code>操作，也就是新建一个叶子节点，然后把原先数据页中的一部分记录复制到这个新的数据页中，然后再把记录插入进去，把这个叶子节点插入到叶子节点链表中，最后还要在内节点中添加一条<code>目录项记录</code>指向这个新创建的页面。很显然，这个过程要对多个页面进行修改，也就意味着会产生多条<code>redo</code>日志，我们把这种情况称之为<code>悲观插入</code>。假如某个索引对应的<code>B+</code>树长这样：</p>
<p></p><figure><img alt="image_1d4fcomne1lpsp691hg2o416hh2t.png-44.5kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694893011fc216e?w=731&amp;h=551&amp;f=png&amp;s=45566"><figcaption></figcaption></figure><p></p>
<p>现在我们要插入一条键值为<code>10</code>的记录，很显然需要被插入到<code>页b</code>中，但是从图中也可以看出来，此时<code>页b</code>已经塞满了记录，没有更多的空闲空间来容纳这条新记录了，所以我们需要进行页面的分裂操作，就像这样：</p>
<p></p><figure><img alt="image_1d4fkn8gv1n7enuq23kt1n1uvk3n.png-96.9kB" src="https://user-gold-cdn.xitu.io/2019/3/4/16948930147d598e?w=951&amp;h=570&amp;f=png&amp;s=99256"><figcaption></figcaption></figure><p></p>
<p>如果作为内节点的<code>页a</code>的剩余空闲空间也不足以容纳增加一条<code>目录项记录</code>，那需要继续做内节点<code>页a</code>的分裂操作，也就意味着会修改更多的页面，从而产生更多的<code>redo</code>日志。另外，对于<code>悲观插入</code>来说，由于需要新申请数据页，还需要改动一些系统页面，比方说要修改各种段、区的统计信息信息，各种链表的统计信息（比如什么<code>FREE</code>链表、<code>FSP_FREE_FRAG</code>链表吧啦吧啦我们在唠叨表空间那一章中介绍过的各种东东）等等等等，反正总共需要记录的<code>redo</code>日志有二、三十条。</p>
</li>
</ul>
<blockquote class="warning"><p>小贴士：

其实不光是悲观插入一条记录会生成许多条redo日志，设计InnoDB的大叔为了其他的一些功能，在乐观插入时也可能产生多条redo日志（具体是为了什么功能我们就不多说了，要不篇幅就受不了了～）。
</p></blockquote><p>设计<code>InnoDB</code>的大叔们认为向某个索引对应的<code>B+</code>树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。比方说在悲观插入过程中，新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向内节点中插入一条<code>目录项记录</code>，这个插入过程就是不完整的，这样会形成一棵不正确的<code>B+</code>树。我们知道<code>redo</code>日志是为了在系统奔溃重启时恢复崩溃前的状态，如果在悲观插入的过程中只记录了一部分<code>redo</code>日志，那么在系统奔溃重启时会将索引对应的<code>B+</code>树恢复成一种不正确的状态，这是设计<code>InnoDB</code>的大叔们所不能忍受的。所以他们规定在执行这些需要保证原子性的操作时必须以<code>组</code>的形式来记录的<code>redo</code>日志，在进行系统奔溃重启恢复时，针对某个组中的<code>redo</code>日志，要么把全部的日志都恢复掉，要么一条也不恢复。怎么做到的呢？这得分情况讨论：</p>
<ul>
<li>
<p>有的需要保证原子性的操作会生成多条<code>redo</code>日志，比如向某个索引对应的<code>B+</code>树中进行一次悲观插入就需要生成许多条<code>redo</code>日志。</p>
<p>如何把这些<code>redo</code>日志划分到一个组里边儿呢？设计<code>InnoDB</code>的大叔做了一个很简单的小把戏，就是在该组中的最后一条<code>redo</code>日志后边加上一条特殊类型的<code>redo</code>日志，该类型名称为<code>MLOG_MULTI_REC_END</code>，<code>type</code>字段对应的十进制数字为<code>31</code>，该类型的<code>redo</code>日志结构很简单，只有一个<code>type</code>字段：</p>
<p></p><figure><img alt="image_1d4fna6k51fok1mpd1tikkmihg144.png-15kB" src="https://user-gold-cdn.xitu.io/2019/3/4/16948930162d677f?w=539&amp;h=199&amp;f=png&amp;s=15317"><figcaption></figcaption></figure><p></p>
<p>所以某个需要保证原子性的操作产生的一系列<code>redo</code>日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：</p>
<p></p><figure><img alt="image_1d4fol2v71fjalphluu1kuf1d8t4h.png-41.4kB" src="https://user-gold-cdn.xitu.io/2019/3/4/16948930164d64a0?w=961&amp;h=300&amp;f=png&amp;s=42384"><figcaption></figcaption></figure><p></p>
<p>这样在系统奔溃重启进行恢复时，只有当解析到类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志，才认为解析到了一组完整的<code>redo</code>日志，才会进行恢复。否则的话直接放弃前边解析到的<code>redo</code>日志。</p>
</li>
<li>
<p>有的需要保证原子性的操作只生成一条<code>redo</code>日志，比如更新<code>Max Row ID</code>属性的操作就只会生成一条<code>redo</code>日志。</p>
<p>其实在一条日志后边跟一个类型为<code>MLOG_MULTI_REC_END</code>的<code>redo</code>日志也是可以的，不过设计<code>InnoDB</code>的大叔比较勤俭节约，他们不想浪费一个比特位。别忘了虽然<code>redo</code>日志的类型比较多，但撑死了也就是几十种，是小于<code>127</code>这个数字的，也就是说我们用7个比特位就足以包括所有的<code>redo</code>日志类型，而<code>type</code>字段其实是占用1个字节的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条<code>redo</code>日志，示意图如下：</p>
<p></p><figure><img alt="image_1d4fqlji7md35pdmvvhvibqb4u.png-27.4kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489301685dcb4?w=869&amp;h=282&amp;f=png&amp;s=28021"><figcaption></figcaption></figure><p></p>
<p>如果<code>type</code>字段的第一个比特位为<code>1</code>，代表该需要保证原子性的操作只产生了单一的一条<code>redo</code>日志，否则表示该需要保证原子性的操作产生了一系列的<code>redo</code>日志。</p>
</li>
</ul>
<h3 class="heading">Mini-Transaction的概念</h3>
<p>设计<code>MySQL</code>的大叔把对底层页面中的一次原子访问的过程称之为一个<code>Mini-Transaction</code>，简称<code>mtr</code>，比如上边所说的修改一次<code>Max Row ID</code>的值算是一个<code>Mini-Transaction</code>，向某个索引对应的<code>B+</code>树中插入一条记录的过程也算是一个<code>Mini-Transaction</code>。通过上边的叙述我们也知道，一个所谓的<code>mtr</code>可以包含一组<code>redo</code>日志，在进行奔溃恢复时这一组<code>redo</code>日志作为一个不可分割的整体。</p>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个<code>mtr</code>组成，每一个<code>mtr</code>又可以包含若干条<code>redo</code>日志，画个图表示它们的关系就是这样：</p>
<p></p><figure><img alt="image_1d4hgjr7t4es1v2mf2b1bt51rf95b.png-27.6kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489303b9e5c9f?w=619&amp;h=559&amp;f=png&amp;s=28248"><figcaption></figcaption></figure><p></p>
<h2 class="heading">redo日志的写入过程</h2>
<h3 class="heading">redo log block</h3>
<p>设计<code>InnoDB</code>的大叔为了更好的进行系统奔溃恢复，他们把通过<code>mtr</code>生成的<code>redo</code>日志都放在了大小为<code>512字节</code>的<code>页</code>中。为了和我们前边提到的表空间中的页做区别，我们这里把用来存储<code>redo</code>日志的页称为<code>block</code>（你心里清楚页和block的意思其实差不多就行了）。一个<code>redo log block</code>的示意图如下：</p>
<p></p><figure><img alt="image_1d4hor6e7nq1mkm1sa41he71rif75.png-57.2kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489303bff8e20?w=785&amp;h=416&amp;f=png&amp;s=58592"><figcaption></figcaption></figure><p></p>
<p>真正的<code>redo</code>日志都是存储到占用<code>496</code>字节大小的<code>log block body</code>中，图中的<code>log block header</code>和<code>log block trailer</code>存储的是一些管理信息。我们来看看这些所谓的<code>管理信息</code>都是啥：</p>
<p></p><figure><img alt="image_1d4hp4u8g13e317mkngoag21clv7i.png-113.9kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489303c1fb389?w=998&amp;h=521&amp;f=png&amp;s=116667"><figcaption></figcaption></figure><p></p>
<p>其中<code>log block header</code>的几个属性的意思分别如下：</p>
<ul>
<li>
<p><code>LOG_BLOCK_HDR_NO</code>：每一个block都有一个大于0的唯一标号，本属性就表示该标号值。</p>
</li>
<li>
<p><code>LOG_BLOCK_HDR_DATA_LEN</code>：表示block中已经使用了多少字节，初始值为<code>12</code>（因为<code>log block body</code>从第12个字节处开始）。随着往block中写入的redo日志越来也多，本属性值也跟着增长。如果<code>log block body</code>已经被全部写满，那么本属性的值被设置为<code>512</code>。</p>
</li>
<li>
<p><code>LOG_BLOCK_FIRST_REC_GROUP</code>：一条<code>redo</code>日志也可以称之为一条<code>redo</code>日志记录（<code>redo log record</code>），一个<code>mtr</code>会生产多条<code>redo</code>日志记录，这些<code>redo</code>日志记录被称之为一个<code>redo</code>日志记录组（<code>redo log record group</code>）。<code>LOG_BLOCK_FIRST_REC_GROUP</code>就代表该block中第一个<code>mtr</code>生成的<code>redo</code>日志记录组的偏移量（其实也就是这个block里第一个<code>mtr</code>生成的第一条<code>redo</code>日志的偏移量）。</p>
</li>
<li>
<p><code>LOG_BLOCK_CHECKPOINT_NO</code>：表示所谓的<code>checkpoint</code>的序号，<code>checkpoint</code>是我们后续内容的重点，现在先不用清楚它的意思，稍安勿躁。</p>
</li>
</ul>
<p><code>log block trailer</code>中属性的意思如下：</p>
<ul>
<li><code>LOG_BLOCK_CHECKSUM</code>：表示block的校验值，用于正确性校验，我们暂时不关心它。</li>
</ul>
<h3 class="heading">redo日志缓冲区</h3>
<p>我们前边说过，设计<code>InnoDB</code>的大叔为了解决磁盘速度过慢的问题而引入了<code>Buffer Pool</code>。同理，写入<code>redo</code>日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为<code>redo log buffer</code>的连续内存空间，翻译成中文就是<code>redo日志缓冲区</code>，我们也可以简称为<code>log buffer</code>。这片内存空间被划分成若干个连续的<code>redo log block</code>，就像这样：</p>
<p></p><figure><img alt="image_1d4i4orkr17vl1m5l3hl1l341pad1j.png-76.5kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489303ceeb982?w=995&amp;h=459&amp;f=png&amp;s=78303"><figcaption></figcaption></figure><p></p>
<p>我们可以通过启动参数<code>innodb_log_buffer_size</code>来指定<code>log buffer</code>的大小，在<code>MySQL 5.7.21</code>这个版本中，该启动参数的默认值为<code>16MB</code>。</p>
<h3 class="heading">redo日志写入log buffer</h3>
<p>向<code>log buffer</code>中写入<code>redo</code>日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往<code>log buffer</code>中写入<code>redo</code>日志时，第一个遇到的问题就是应该写在哪个<code>block</code>的哪个偏移量处，所以设计<code>InnoDB</code>的大叔特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的<code>redo</code>日志应该写入到<code>log buffer</code>中的哪个位置，如图所示：</p>
<p></p><figure><img alt="image_1d4jsb3pac9t1pl76drruf1b0574.png-98.4kB" src="https://user-gold-cdn.xitu.io/2019/3/4/1694893043dc7344?w=842&amp;h=542&amp;f=png&amp;s=100778"><figcaption></figcaption></figure><p></p>
<p>我们前边说过一个<code>mtr</code>执行过程中可能产生若干条<code>redo</code>日志，这些<code>redo</code>日志是一个不可分割的组，所以其实并不是每生成一条<code>redo</code>日志，就将其插入到<code>log buffer</code>中，而是每个<code>mtr</code>运行过程中产生的日志先暂时存到一个地方，当该<code>mtr</code>结束的时候，将过程中产生的一组<code>redo</code>日志再全部复制到<code>log buffer</code>中。我们现在假设有两个名为<code>T1</code>、<code>T2</code>的事务，每个事务都包含2个<code>mtr</code>，我们给这几个<code>mtr</code>命名一下：</p>
<ul>
<li>
<p>事务<code>T1</code>的两个<code>mtr</code>分别称为<code>mtr_T1_1</code>和<code>mtr_T1_2</code>。</p>
</li>
<li>
<p>事务<code>T2</code>的两个<code>mtr</code>分别称为<code>mtr_T2_1</code>和<code>mtr_T2_2</code>。</p>
</li>
</ul>
<p>每个<code>mtr</code>都会产生一组<code>redo</code>日志，用示意图来描述一下这些<code>mtr</code>产生的日志情况：</p>
<p></p><figure><img alt="image_1d4ie92r31t57c94e661n861skv2t.png-95.1kB" src="https://user-gold-cdn.xitu.io/2019/2/25/1692548dcc3fe243?w=956&amp;h=507&amp;f=png&amp;s=97414"><figcaption></figcaption></figure><p></p>
<p>不同的事务可能是并发执行的，所以<code>T1</code>、<code>T2</code>之间的<code>mtr</code>可能是交替执行的。每当一个<code>mtr</code>执行完成时，伴随该<code>mtr</code>生成的一组<code>redo</code>日志就需要被复制到<code>log buffer</code>中，也就是说不同事务的<code>mtr</code>可能是交替写入<code>log buffer</code>的，我们画个示意图（为了美观，我们把一个<code>mtr</code>中产生的所有的<code>redo</code>日志当作一个整体来画）：</p>
<p></p><figure><img alt="image_1d4jsd7861q6dn9n17gs1cdd1kek7h.png-102.6kB" src="https://user-gold-cdn.xitu.io/2019/3/4/169489304969c9d7?w=823&amp;h=419&amp;f=png&amp;s=105070"><figcaption></figcaption></figure><p></p>
<p>从示意图中我们可以看出来，不同的<code>mtr</code>产生的一组<code>redo</code>日志占用的存储空间可能不一样，有的<code>mtr</code>产生的<code>redo</code>日志量很少，比如<code>mtr_t1_1</code>、<code>mtr_t2_1</code>就被放到同一个block中存储，有的<code>mtr</code>产生的<code>redo</code>日志量非常大，比如<code>mtr_t1_2</code>产生的<code>redo</code>日志甚至占用了3个block来存储。</p>
<blockquote class="warning"><p>小贴士：

对照着上图，自己分析一下每个block的LOG_BLOCK_HDR_DATA_LEN、LOG_BLOCK_FIRST_REC_GROUP属性值都是什么哈～
</p></blockquote>